// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents;
float width;
float height;
float deltaTime;
float time;
static float pi = 3.1415;

// source: www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

float when_gt(float x, float y) {
    return max(sign(x - y), 0.0);
}

float2 when_gt(float2 x, float2 y) {
    return max(sign(x - y), 0.0);
}

float2 when_lt(float2 x, float2 y) {
    return max(sign(y - x), 0.0);
}

float scaleTo01(uint value)
{
    return value / 4294967295.0;
}

float2 setByResultMultiplicationWhen(float2 currentValue, float when, float2 newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

float setByResultMultiplicationWhen(float currentValue, float when, float newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];

    uint seed = (agent.position.y * width + agent.position.x) + hash(id.x + time * 100000);

    uint random = hash(seed);
    float random01 = scaleTo01(random);
    float randomAngle = random01 * 2 *pi;

    //if (newPos.x > width || newPos.x < 0 || newPos.y < 0 || newPos.y > height)


    float2 dir = float2(cos(randomAngle), sin(randomAngle));
    float2 newPos = agent.position + dir * deltaTime;
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.x, textureSize.x), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.y, textureSize.y), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.x, 0), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.y, 0), randomAngle);

    // newPos.x = min(width - 1, max(0, newPos.x));
    // newPos.y = min(height - 1, max(0, newPos.y));
    agent.angle = randomAngle;
    //agent.position = newPos;
    agents[id.x] = agent;

    // if (id.x > width || id.x < 0 || id.y < 0 || id.y > height)
    // {
    //     return;
    // }


    float angleColor = random01 * 255;
    int index = angleColor * width + angleColor;

    if (angleColor < 80)
    {
        Result[newPos] = float4(angleColor,0,0,255);
    }
    else if (angleColor > 80 && angleColor < 160)
    {
        Result[newPos] = float4(0,angleColor,0,255);
    }
    else
    {
        Result[newPos] = float4(0,0,angleColor,255);
    }


}

#pragma kernel Clear

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(0,0,0,0);
}
