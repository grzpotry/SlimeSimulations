// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateMovement

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct TrailSensor
{
    float angle;
};

struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents;
float width;
float height;
float deltaTime;
float time;
float speed;
float evaporationSpeed;
float diffuseSpeed;

float sensorAngle;
int sensorWidth;
float sensorOffsetDistance;

static float pi = 3.1415;

// source: www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

float when_gt(float x, float y) {
    return max(sign(x - y), 0.0);
}

float2 when_gt(float2 x, float2 y) {
    return max(sign(x - y), 0.0);
}

float2 when_lt(float2 x, float2 y) {
    return max(sign(y - x), 0.0);
}

float scaleTo01(uint value)
{
    return value / 4294967295.0;
}

float2 setByResultMultiplicationWhen(float2 currentValue, float when, float2 newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

float setByResultMultiplicationWhen(float currentValue, float when, float newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

[numthreads(8,8,1)]
void UpdateMovement (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];
    float2 dir = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + dir * speed * deltaTime;


    uint seed = (agent.position.y * width + agent.position.x) + hash(id.x + time * 100000);
    uint random = hash(seed);
    float random01 = scaleTo01(random);
    float randomAngle = random01 * 2 * pi;

    //change to random angle when out of texture viewport without conditionals
    agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.x, width - 1), randomAngle);
    agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.y, height - 1), randomAngle);
    agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.x, 0), randomAngle);
    agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.y, 0), randomAngle);

    //clamp position
    newPos.x = min(width - 1, max(0, newPos.x));
    newPos.y = min(height - 1, max(0, newPos.y));

    agent.position = newPos;
    agents[id.x] = agent;
    Result[newPos] = 255;
}

#pragma kernel UpdateSensors

float CalculateSensorValue(float2 agentPos, float2 dir, float4 debugSensorColor)
{
    float sum = 0;

    for (int x = -sensorWidth; x < sensorWidth; x++)
    {
        for (int y = -sensorWidth; y < sensorWidth; y++)
        {
            float2 sensorPos = agentPos + dir * sensorOffsetDistance + int2(x,y);
            sum += dot(Result[sensorPos], 1);
            //Result[sensorPos] = debugSensorColor; uncomment for debug
        }
    }
    return sum;
}

[numthreads(8,8,1)]
void UpdateSensors (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.z];

    float2 forwardDir = float2(cos(agent.angle), sin(agent.angle));
    float2 rightDir = float2(cos(agent.angle + sensorAngle), sin(agent.angle + sensorAngle));
    float2 leftDir = float2(cos(agent.angle - sensorAngle), sin(agent.angle - sensorAngle));

    float forward = CalculateSensorValue(agent.position, normalize(forwardDir), float4(255, 0, 0, 255));
    float forwardR = CalculateSensorValue(agent.position, normalize(rightDir), float4(0, 255, 0, 255));
    float forwardL = CalculateSensorValue(agent.position, normalize(leftDir), float4(0, 0, 255, 255));

    if (forward > forwardL && forward > forwardR)
    {
        return;
    }

    uint seed = (agent.position.y * width + agent.position.x) + hash(id.x + time * 100000);
    uint random = hash(seed);
    float random01 = scaleTo01(random);

    if (forward < forwardL && forward < forwardR)
    {
        float randomTurnAngle = random01 * sensorAngle * 2 - sensorAngle;
        agent.angle += randomTurnAngle;
    }
    else if (forwardL < forwardR)
    {
        float randomTurnAngle = random01 * sensorAngle;
        agent.angle += randomTurnAngle;
    }
    else if (forwardR > forwardL)
    {
        float randomTurnAngle = random01 * sensorAngle;
        agent.angle -= randomTurnAngle;
    }
    else
    {
        return;
    }

    agents[id.z] = agent;
}


#pragma kernel EvaporateTrail

[numthreads(8,8,1)]
void EvaporateTrail (uint3 id : SV_DispatchThreadID)
{

}

#pragma kernel Clear
[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(0,0,0,0);
}

#pragma kernel Blur

[numthreads(8,8,1)]
void Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x <=0 || id.x >= width -1 || id.y <=0 || id.y >= height - 1)
    {
        return;
    }
    float4 blurred = 0;

    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            float2 coords = id.xy + float2(x,y);
            if (coords.x >=0 && coords.x < width && coords.y >=0 && coords.y < height)
            {
                blurred+= Result[coords];
            }
        }
    }

    blurred = blurred / 9.0;



    float4 diffused = lerp(Result[id.xy], blurred, deltaTime * diffuseSpeed);

    diffused -= evaporationSpeed * deltaTime;
    diffused = max(diffused, 0);
    Result[id.xy] =diffused;
}

