// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents;
float width;
float height;
float deltaTime;
float time;
float speed;
float evaporationSpeed;
static float pi = 3.1415;

// source: www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

float when_gt(float x, float y) {
    return max(sign(x - y), 0.0);
}

float2 when_gt(float2 x, float2 y) {
    return max(sign(x - y), 0.0);
}

float2 when_lt(float2 x, float2 y) {
    return max(sign(y - x), 0.0);
}

float scaleTo01(uint value)
{
    return value / 4294967295.0;
}

float2 setByResultMultiplicationWhen(float2 currentValue, float when, float2 newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

float setByResultMultiplicationWhen(float currentValue, float when, float newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];

    float2 dir = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + dir * speed * deltaTime;

    if (newPos.x > width-1 || newPos.x < 0 || newPos.y < 0 || newPos.y > height-1)
    {
        uint seed = (agent.position.y * width + agent.position.x) + hash(id.x + time * 100000);
        uint random = hash(seed);
        float random01 = scaleTo01(random);
        float randomAngle = random01 * 2 *pi;
        agent.angle = randomAngle;
    }

    newPos.x = min(width - 1, max(0, newPos.x));
    newPos.y = min(height - 1, max(0, newPos.y));

    agent.position = newPos;
    agents[id.x] = agent;
    Result[newPos] = 255;

    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.x, textureSize.x), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.y, textureSize.y), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.x, 0), randomAngle);
    // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.y, 0), randomAngle);
}

#pragma kernel EvaporateTrail

[numthreads(8,8,1)]
void EvaporateTrail (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] -= evaporationSpeed;
    Result[id.xy] = max(Result[id.xy], 0);
}

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(0,0,0,0);
}
