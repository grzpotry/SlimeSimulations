// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents;
float width;
float height;
float deltaTime;
const float pi = 3.14159265359;

// source: www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

float when_gt(float x, float y) {
    return max(sign(x - y), 0.0);
}

float2 when_gt(float2 x, float2 y) {
    return max(sign(x - y), 0.0);
}

float2 when_lt(float2 x, float2 y) {
    return max(sign(y - x), 0.0);
}

float scaleTo01(uint value)
{
    return value / 4294967295.0;
}

float2 setByResultMultiplicationWhen(float2 currentValue, float when, float2 newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

float setByResultMultiplicationWhen(float currentValue, float when, float newValue)
{
    return (1 + when * (newValue - 1)) / (1 + when * (currentValue - 1));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: uncomment, fix hash function

    // Agent agent = agents[id.z];
    //
    // float dir = float2(cos(agent.angle), sin(agent.angle));
    // float2 newPos = agent.position + dir * deltaTime;
    // uint seed = newPos.y * width + newPos.x * height + hash(id.x + deltaTime * 1000000);
    // // uint random = hash(pos.y * width + pos.x + hash(id.x + time * 100000));
    //
    // uint random = hash(seed);
    // float random01 = scaleTo01(random);
    // float randomAngle = random01 * 2 *pi;
    //
    // if (newPos.x > width || newPos.x < 0 || newPos.y < 0 || newPos.y > height)
    // {
    //     agent.angle = randomAngle;
    // }
    //
    // // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.x, textureSize.x), randomAngle);
    // // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_gt(newPos.y, textureSize.y), randomAngle);
    // // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.x, 0), randomAngle);
    // // agent.angle *= setByResultMultiplicationWhen(agent.angle, when_lt(newPos.y, 0), randomAngle);
    //
    // newPos.x = min(width - 1, max(0, newPos.x));
    // newPos.y = min(height - 1, max(0, newPos.y));
    // agent.position = newPos;
    // agents[id.z] = agent;

    if (id.x > width || id.x < 0 || id.y < 0 || id.y > height)
    {
        return;
    }

    int index = id.y * width + id.x;

    Result[id.xy] = hash(index) / 4294967295.0;
}
